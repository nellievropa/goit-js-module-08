{"mappings":"AA2I0C,MAApCA,EAAO,CAACC,EAAKC,KACf,IACE,MAAMC,EAAkBC,KAAKC,UAAUH,GACvCI,aAAaC,QAAQN,EAAKE,E,CAC1B,MAAOK,GACPC,QAAQD,MAAM,oBAAqBA,EAAME,Q,GAKDV,EAAzC,QAAS,CAACW,KAAK,kBACpBX,EAAK,SAAU,yBAEb,MAAMY,EAAOX,IACX,IACE,MAAME,EAAkBG,aAAaO,QAAQZ,GAC7C,OAA2B,OAApBE,OAA2BW,EAAYV,KAAKW,MAAMZ,E,CACzD,MAAOK,GACPC,QAAQD,MAAM,oBAAqBA,EAAME,Q,GAI7CD,QAAQO,IAAIJ,EAAK,UASnB,MAAMK,EAAUC,SAASC,cAAc,YACjCC,EAAUF,SAASC,cAAc,eAEvCF,EAAQI,mBAAmB,YAAaC,KACxCL,EAAQM,iBAAiB,SA0EzB,SAAiBC,GAEb,GAAKA,EAAIC,OAAOC,YAkCZC,MAAM,iBAlCmB,CACzBH,EAAIC,OAAOC,YAAcE,EAEzB,MAAMC,EAAKC,OAAON,EAAIC,OAAOM,QAAQF,IAEd,IAAnBG,EACU,MAAXJ,GACCK,EAAMC,KAAKL,GACXvB,aAAaC,QAhFX,UAgF0BH,KAAKC,UAAU4B,IAC3CD,EAASG,EAASF,KAKlBG,EAAMF,KAAKL,GACXvB,aAAaC,QAtFX,UAsF0BH,KAAKC,UAAU+B,IAC3CJ,EAASG,EAASC,IAIxBC,YAAW,KACT,GAAIL,EAIA,OAHAL,MAAM,aAAaC,UAEoBU,IAG3CV,EAAoB,MAAXA,EAAiB,IAAM,GAAG,G,KAtG3CR,EAAQG,iBAAiB,QAASe,GAKlC,IAAIV,EAAS,IAETK,EAAQ7B,KAAKW,MAAMT,aAAaO,QAJtB,aAIyC,GACnDuB,EAAQhC,KAAKW,MAAMT,aAAaO,QAJtB,aAIyC,GAUvD,MAAM0B,EAAM,CACR,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,IAmC2C,SAA7CJ,EAASK,GACd,OAAOD,EAAIE,MAAKC,GAAQA,EAAKC,OAAMd,GAAMW,EAAII,SAASf,M,CAG1D,SAASP,IACL,IAAIuB,EAAS,GACb,IAAK,IAAIC,EAAI,EAAGA,GAAK,EAAGA,GAAK,EACjCD,GAAU,8BAA8BC,YAEpC,OAAOD,C,CAoDX,SAASP,IACLV,EAAS,IACTK,EAAQ,GACRG,EAAQ,GACR9B,aAAayC,WAAW,SACxBzC,aAAayC,WAAW,SAExB9B,EAAQ+B,UAAY1B,G,CA/FpB,IAAIL,EAAQgC,UAAUC,SAAQR,IAC1B,MAAMb,EAAKC,OAAOY,EAAKX,QAAQF,IAI5BI,EAAMW,SAASf,GACda,EAAKhB,YAAc,IACdU,EAAMQ,SAASf,KACpBa,EAAKhB,YAAc,IAAG","sources":["src/js/index.js"],"sourcesContent":["// // 1 отримали контейнер з HTML\n// const container = document.querySelector('.js-content')\n// // console.log(container);\n// // 2 створюємо гравця Х по дефолту\n// let player = \"X\";\n// // 3 створимо історії ходів двох гравців і їх пусті масиви, які будуть заповнюватися даними\n// // щоб легко було очистити поля задамо змінні через Let а не const\n// let historyX = [];\n// let historyO = [];\n// // 4 створюємо масив масивів всіх виграшних комбінацй\n// const wins = [\n//     [1, 2, 3],\n//     [3, 6, 9],\n//     [4, 5, 6],\n//     [7, 8, 9],\n//     [1, 4, 7],\n//     [2, 5, 8],\n//     [1, 5, 9],\n//     [3, 5, 7],\n// ];\n// //5 Створюємо функцію генерування розмітки\n// //6 створюємо  змінну markup, в яку кожен раз буде додаватися нове поле ігрове div, у якого клас js-item - щоб первірити куди ми клікнули і data-id -щоб записувати історію ходів\n// // і переносимо її функцію createMarkup()\n// // створюємо нову функцию, щоб можна було перевикористовувати, і переносимо дані в неї\n// function createMarkup() {\n//     let markup = \"\";\n//     for (let i = 1; i < 10; i += 1){\n//         markup += `<div class=\"item js-item\" data-id=\"${i}\"></div>`;\n//     }\n//     // console.log(markup);\n//     //7 наповнили наш HTML контейнер квадратиками!!\n//     container.innerHTML = markup;\n// }\n// // і зразу її викликаємо\n// createMarkup();\n\n// //8 щоб знати, на який квадратик клікаєм на БАТЬКІВСЬКИЙ елемент вішаємо прослуховувача\n// container.addEventListener('click', onClick);\n\n// function onClick(evt) {\n//     //9 Делегували подій робимо через Деструктуризацію таргета - коли побвачили, що елемент часто повторюється- робимо змінну і прибираємо його з коду\n//     const { target } = evt;\n// // якщо ми клікнули НЕ на квадратик, то одразу виходимо\n// // 10 перевіряємо якщо наш елемент не містить класу \"js-item\" або якщо його текстовий контент зайнятий!!!- то зразу виходимо \n//     if (!target.classList.contains(\"js-item\") || target.textContent) {\n//         return;\n//     }\n//     // а потім другу умову додаємо через або в перший иф\n//     // ця умова не дає змінювати Х на 0 на ОДНІЙ клітинці!!!\n//     // якщо клітинка пуста - дозволяємо хід, якщо зайнята - не дозволяємо\n//     // if (etarget.textContent) {\n//     //     return;\n//     // }\n//     // щоб дізнатись ID клітинки на яку клікнули- шукаємо її номер, зразу для обох ігроків\n//      // але з data atributa  він прийде у форматі рядка, а наші масиви- то числа тому приводимо його до числа \n\n//     // const { id } = Number(target.dataset); - так не працює, тому змінюємо на \n//     // 11 Дістаємо id кожної клітинки і приводимо його до числа\n//     const  id  = Number(target.dataset.id);\n//     // створимо змінну для переможця\n// let result = false;\n// // 23 робимо змінну на перевірку кількості ходів \n// const isEndGame = historyO.length + historyX.length === 9;\n//     // 12 Ідемо і перевіряємо, якщо поточний гравець здійснив хід- пушим його в історію\n//     // нам треба визначитись, хто робить хід, тому створюємо умову\n//     if (player === \"X\") {\n//         historyX.push(id);\n//         // 13 Змінній result присвоюємо результат виконання функції isWinner\n//         result = isWinner(historyX)\n//     } else {\n//         historyO.push(id);\n//         result = isWinner(historyO)\n//     }\n//       // текстовий контент елемента, по якому клікнули = Х - це перший ход\n//     //   17 перевизначаємо хід для наступного гравця\n//       target.textContent = player;\n//     //   18 якщо результат TRUE - у нас є переможець і ми підставляємо його в результат ${player}\n//     if (result) {\n//         console.log(`Winner is ${player}`);\n//         // 19 і перезавантажуємо гру функцією resetGame(), яка прописана нижче\n//         resetGame();\n//         return;\n//         // 22 якщо переможця немає, але всі клітинки запонились\n//         // перевіряємо кількість ходів і щоб не робити таку довгу умову виносимо цю перевірку в змінну\n//         // а тут тоді перевіряємо на булеве значення\n//     }else if(isEndGame) {\n// console.log(`Try again!`);\n// resetGame();\n// return;\n//     }\n// // отримуємо просто номер  const {id} = target.dataset\n//     // але з data atributa  він прийде у форматі рядка, а наші масиви- то числа \n//     // console.log('X', historyX);\n//     //  console.log('0', history0);\n//     // console.log( isWinner(historyX));\n  \n// //21 якщо переможця не визначено то ми змінюємо чергу ходу\n// //  змінюємо чергу ходу на 0: якщо був Х змінюємо на 0\n// // перевизначаємо player = \n//     player = player === 'X' ? 'O' : 'X';\n\n//     // currentTarget-батько(весь контейнер\n//     // target-кожен маленький квадратик)\n//     // console.log(evt.currentTarget);\n//     // console.log(evt.target)\n// }\n// // щоб визначити, хто виграв нам потрібно знати ID клітинки!!!\n// // тому ми його додаємо в код вище!\n\n// // створимо функцію, яка буде перевіряти чи виграв хтось з гравців\n// // порівнювати з виграшими комбінаціями\n// // в функцыю приходить історыя ходів в вигляді масива\n// // 14 в цій функції перевіряємо чи історія ходів є виграшною!\n// function isWinner(arr) {\n// //15 ми  перебираємо масив wins з допомогою методу some\n// // перевіряємо чи є в історії ходів подібна комбінація цифр\n// // 16 наша умова для методу some це результат виконання методу every\n//                     //   [2, 5, 8]\n// return wins.some((item) => item.every(id => arr.includes(id))); \n//                     //every повертає  TRUE тільки якщо ВСІ елементи задовільнили умові\n// }\n\n// // щоб очищати ігрові поля створимо функцію resetGame і викличемо її в тому разі коли є переможець\n// function resetGame(){\n//     // 20.1 запускає функцію створення розмітки\n//     createMarkup();\n//     // 20.2 визначає пустим масивом історії Х і О\n//     historyX = [];\n//     historyO = [];\n//     // 20.3 повертаемо до початкового плеєра Х\n//     player = \"X\";\n// }\n\n\n// майже сталий вираз\n// є функції save, яка відпоавідає за збереження данних та load, яка отримує значення з локалсторідж\n//  ці функції створюються, щоб зберігти час та сили і не повторювати код\n// бо операції з ключами локалсторіджа одні й ті самі\n\nconst save = (key, value) => {\n    try {\n      const serializedState = JSON.stringify(value);\n      localStorage.setItem(key, serializedState);\n    } catch (error) {\n      console.error(\"Set state error: \", error.message);\n    }\n  };\n  \n//   викликаємо цю функцію і передаємо дані для збереження\nsave('TEST:', {name:\"Hello World!!\"});\nsave('TEST1:', \"Hello all the World!!\");\n\n  const load = key => {\n    try {\n      const serializedState = localStorage.getItem(key);\n      return serializedState === null ? undefined : JSON.parse(serializedState);\n    } catch (error) {\n      console.error(\"Get state error: \", error.message);\n    }\n  };\n  \n  console.log(load('TEST:'));\n\n  export default {\n    save,\n    load,\n  };\n\n\n\nconst content = document.querySelector('.content')\nconst restart = document.querySelector('.js-restart');\n// const winner = document.querySelector('.js-winner');\ncontent.insertAdjacentHTML('beforeend', createMarkup())\ncontent.addEventListener('click', onClick);\nrestart.addEventListener('click', onRestart);\n// winner.addEventListener('click', onCurrentWinner);\n// назви ключів виносяться в змінні, бо до них будемо звертатися декілька разів\nconst KEY_X = 'PlayerX';\nconst KEY_O = 'PlayerO';\nlet player = 'X';\n// масиви для збереження даних про ходи\nlet stepX = JSON.parse(localStorage.getItem(KEY_X)) || [];\nlet stepO = JSON.parse(localStorage.getItem(KEY_O)) || [];\n\n// const WIN_X = 'сurrentWinX';\n// const WIN_O = 'сurrentWinO';\n// let сurrentWinX = 0;\n// let currentWinO = 0;\n\n// let winHistory_X = JSON.parse(localStorage.getItem(WIN_X));\n// let winHistory_O = JSON.parse(localStorage.getItem(WIN_O));\n\nconst win = [\n    [1, 2, 3],\n    [3, 6, 9],\n    [4, 5, 6],\n    [7, 8, 9],\n    [1, 4, 7],\n    [2, 5, 8],\n    [1, 5, 9],\n    [3, 5, 7]\n];\n\nfunction startGame() {\n    // console.dir(content);\n    // для HTML не приміняється forEach\n    // console.log(stepX);\n    // console.log(stepO);\n    [...content.children].forEach(item => {\n        const id = Number(item.dataset.id)\n        // console.log(id);\n        // console.log(stepX)\n        // console.log(stepX.includes(id))\n        if(stepX.includes(id)) {\n            item.textContent = 'X';\n        }else if(stepO.includes(id)){\n            item.textContent = 'O';\n\n        }\n    })\n}\nstartGame();\n\n// приклад методів сам і еврі\n// const stepX = [2, 5, 3, 8, 9];\n// const test = [1, 2, 3]\n// // console.log(test.every(id => stepX.includes(id)))\n// const isTrue = test.every(id => stepX.includes(id));\n// // візьмемо наш масив win і подивимось чи ХОТЬ ОДИН його елемент item відповідає\n// console.log(win.some(item => console.log(item)))\n\n\n// перебираємо масив win методом some, далі на кожній ітерації some перебираємо масив stepX.push(id); методм every \n// і дивимся, щоб співпали всі числа з виграшною комбінацією\n// метод every потребує щоб співпали всі значення, тільки тоді він видась TRUE\nfunction isWinner(arr) {\n    return win.some(item => item.every(id => arr.includes(id)))\n    }\n    \nfunction createMarkup() {\n    let markup = '';\n    for (let i = 1; i <= 9; i += 1)  {\nmarkup += `<div class=\"item\" data-id=\"${i}\"></div>`\n    }\n    return markup;\n}\n\nfunction onClick(evt) {\n\n    if (!evt.target.textContent) {\n        evt.target.textContent = player;\n        // console.dir(evt.target);\n        const id = Number(evt.target.dataset.id);\n    //   по дефолту переможця немає\n        let result;\n        if(player === \"X\") {\n            stepX.push(id);\n            localStorage.setItem(KEY_X, JSON.stringify(stepX));\n            result = isWinner(stepX);\n            // winHistory_X = сurrentWinX + 1;\n            // localStorage.setItem(WIN_X, JSON.stringify(winHistory_X));\n           \n        }else {\n            stepO.push(id)\n            localStorage.setItem(KEY_O, JSON.stringify(stepO));\n            result = isWinner(stepO);\n            // winHistory_O = currentWinO + 1;\n            // localStorage.setItem(WIN_O, JSON.stringify(winHistory_O));\n        }  \n      setTimeout(() =>{\n        if (result) {\n            alert(`Winner is ${player}`);\n            // очистити поле після того, як знайшли переможця\n            onRestart();\n            return;\n        }\n        player = player === \"X\" ? \"0\" : \"X\";   \n      })\n     \n    //    console.log('stepX', stepX);\n    //    console.log('stepO', stepO);\n           \n    } else {\n        alert('Change!!!')\n    }\n}\n\n// function onCurrentWinner() {\n// if(winHistory_O < winHistory_X) {\n//     alert(`PlayerX won ${localStorage.getItem(WIN_X)} times`)\n// }else {\n//     alert(`PlayerX won ${localStorage.getItem(WIN_O)} times`)\n// }\n   \n// }\n\nfunction onRestart() {\n    player = \"X\";\n    stepX = [];\n    stepO = [];\n    localStorage.removeItem('KEY_X')\n    localStorage.removeItem('KEY_O')\n    // localStorage.clear()\n    content.innerHTML = createMarkup();\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// const session = document.querySelector('.session');\n// const local = document.querySelector('.local');\n// const remove = document.querySelector('.remove');\n\n// session.addEventListener('click', onSession);\n// const arr =[1,2,3,4,5,]\n// function onSession() {\n//     // sessionStorage.setItem('session', 'hello session');\n//     const data = JSON.parse(localStorage.getItem('local')) || [];\n//     console.log(data);\n//     // якщо це- const arr =[1,2,3,4,5,]-масив то й тут додаємо пустий масив \n//     // const resp = JSON.parse(data)\n//     // console.log(resp);\n//     // sessionStorage.setItem('session', arr);\n\n//     data.forEach(element => {\n//         console.log(element);\n//     });\n// }\n\n// local.addEventListener('click', onLocal);\n\n// function onLocal() {\n//     // приводимо до рядка\n//     localStorage.setItem('local', JSON.stringify(arr));\n//     localStorage.setItem('local1', JSON.stringify(arr));\n//     localStorage.setItem('local2', JSON.stringify(arr));\n// }\n\n// remove.addEventListener('click', onRemove)\n\n// function onRemove() {\n// // localStorage.removeItem('local');\n// localStorage.clear();\n// }\n"],"names":["$85a5f86b715fe7db$var$save","key","value","serializedState","JSON","stringify","localStorage","setItem","error","console","message","name","$85a5f86b715fe7db$var$load","getItem","undefined","parse","log","$85a5f86b715fe7db$var$content","document","querySelector","$85a5f86b715fe7db$var$restart","insertAdjacentHTML","$85a5f86b715fe7db$var$createMarkup","addEventListener","evt","target","textContent","alert","$85a5f86b715fe7db$var$player","id","Number","dataset","result","$85a5f86b715fe7db$var$stepX","push","$85a5f86b715fe7db$var$isWinner","$85a5f86b715fe7db$var$stepO","setTimeout","$85a5f86b715fe7db$var$onRestart","$85a5f86b715fe7db$var$win","arr","some","item","every","includes","markup","i","removeItem","innerHTML","children","forEach"],"version":3,"file":"index.e9c8786c.js.map"}